# Defining an SDM

Most of the documentation we've written assumes that you have an SDM configured, and we've shown you what an SDM can do by defining transformations. But how does one _start_ with a completely blank SDM? In this tutorial, we're going to build an SDM entirely from scratch, one that performs delivery goals in response to a Git push.

-   Autofix and fingerprint code in a repository
-   Build an artifact from that code
-   Deploy that artifact to S3

We'll run all of these against a Node repository. To keep things simple, these goals will only contain sample code.

## Getting started

Run `atomist create sdm` and select "blank" as your SDM type. Feel free to name it anything you like, but in this tutorial, we're going to call it `my-blank-sdm`:

```
? Type of SDM to create blank
Please follow the prompts to create a new SDM

? name of the target repository my-blank-sdm
? (mapped parameter) target-owner <user>
```

Navigate to the directory created for you, run `npm install` to grab the Node dependencies, and then open the folder up in your editor of choice.

Unlike some of our other tutorials, where we focus on the code to implement a goal, in this tutorial we're going to start from the `index.ts` file and set up what we want our actions to be. Your editor will probably complain about TypeScript warnings, and that's okay! This is only meant to be a broad demonstration of what Atomist can do.

## Defining your code cleanup steps

To start with, we said we wanted to autofix and fingerprint new commits that were pushed. To do that, let's first import the necessary packages at the top of `index.ts`:

```typescript
import {
    Autofix,
    Fingerprint,
    SoftwareDeliveryMachine,
    SoftwareDeliveryMachineConfiguration,
} from "@atomist/sdm";
```

Next, within the `configure` function, let's set up some dummy code that will eventually call real, working functions:

```typescript
const autofix = new Autofix().with(quoteLinter);

const fingerprint = new Fingerprint().with(packageLockFingerprinter);
```

An [autofix](https://docs.atomist.com/developer/autofix/) is a type of code transform; as its name implies, it will automatically fix code that has changed to conform to a standard you've defined. This has the role of behaving exactly as a linter might, except that individual developers on your team don't need to remember to set up or configure their editor. They can code as they wish, and the SDM will handle any non-compliant syntaxes for them. For this example, we'll pass `Autofix` a function called `quoteLinter`.

After that, we'll [fingerprint](https://docs.atomist.com/developer/fingerprint/) the code. This is, essentially, a snapshot. Fingerprints can be useful when generating artifacts (as we will do in this tutorial) because they allow you to reference a "point in time" of your source code. If that sounds similar to a commit, it is--except that a fingerprint also refers to more than just code changes. In this example, we'll assume a fingerprint is created for our dependencies installed by npm.

## Defining your build step

With the code all cleaned up, we will want to build an artifact. In compiled language, like Java, a build is considered to be a necessary step performed by a compiler to get an executable or a library. But a build step can also be useful for less rigorous output, such as turning Markdown files into static HTML, or, in the case of some Node projects, turning TypeScript into JavaScript.

At the top of your `index.ts` file, let's import two predefined functions useful for building Node packages:

```typescript
import { Build } from "@atomist/sdm-pack-build";
import {
    nodeBuilder,
    NodeModulesProjectListener,
} from "@atomist/sdm-pack-node";
```

You might not have these modules in your SDM, so be sure to install them as well:

```
$ npm install @atomist/sdm-pack-build
$ npm install @atomist/sdm-pack-node
```

And now, let's define our build step. In this case, we'll defer just to running the `build` command defined in our `package.json` file:

```typescript
const build = new Build()
    .with({
        name: "npm",
        builder: nodeBuilder({ command: "npm", args: ["run", "build"] }),
    })
    .withProjectListener(NodeModulesProjectListener);
```

`NodeModulesProjectListener` is an interesting nicety. It is a type of [`GoalProjectListener`](https://docs.atomist.com/developer/goals-more/#create-a-goalprojectlistener) that first identifies whether or not a project is even a Node project, and if it is, runs `npm install` before running a build. This means that the different components of your SDM can remain the same while still performing different actions depending on the language of the repository.

## Defining your goal step

Our last task here is to deploy the artifact generated by the build step. Depending on your application, there are are many different choices to make here.

To mimic what you might actually do in production, we'll send our build output to S3. Doing so requires you to import a new package, [`sdm-pack-s3`](https://github.com/atomist/sdm-pack-s3) (which we maintain):

```typescript
import { PublishToS3 } from "@atomist/sdm-pack-s3";
```

You'll probably need to install this package, too:

```
$ npm install @atomist/sdm-pack-s3
```

The `PublishToS3` function takes several configuration values, but the most important ones are

-   Your S3 bucket name
-   Your S3 region
-   The files to publish

Here's a sample of what such code might look like:

```typescript
const publish = new PublishToS3({
    uniqueName: "publish artifacts to s3",
    bucketName: "project.foo.com",
    region: "us-east-1",
    filesToPublish: ["build/**/*"],
});
```

## Creating a goal

Right now, we have several disparate steps defined as variables: `autofix`, `fingerprint`, `build`, and `publish`.
Our penultimate step is to create a goal that encapsulates these actions.
There are [several ways to set a goal](https://docs.atomist.com/developer/set-goals/),
and we'll go over a few of them briefly.

### Creating a goal set

The quickest way to make use of a goal is to create a goal set. A goal set groups together previously defined steps as one unit. For example, to combine all of the previous steps into one, you could try:

```typescript
const ReleaseGoal = goals("release artifacts").plan(
    autofix,
    fingerprint,
    build,
    publish
);
```

However, goal sets execute in parallel, so this probably isn't what you want. Instead, consider grouping parallelizable steps into their own goals, like this:

```typescript
const CleanCodeGoal = goals("release artifacts").plan(autofix, fingerprint);

const BuildGoal = goals("release artifacts").plan(build);

const PublishGoal = goals("release artifacts").plan(publish);
```

Another option is to make use of the `after` method, which adds a dependency from one task to another:

```typescript
const ReleaseGoal = goals("release artifacts")
    .plan(autofix, fingerprint)
    .plan(build)
    .after(autofix)
    .plan(publish)
    .after(build);
```

Although for this small SDM, setting up goal sets like this might not seem necessary, for larger projects it makes all the difference--and to understand why, we'll need to dive into our next section.

### Executing goals on push

To actually _run_ these goals, we need to tell the SDM when to do so. This is done through the use of push rules. A push rule executes a goal based on the type of push made.

If your SDM is small, like ours is, you could just run all the goals on any push:

```typescript
sdm.addPushRules(onAnyPush().setGoals(ReleaseGoal));
```

However, with larger projects, you will want to establish conditions through push tests, which execute goals only if a condition is met. For example, if you want an SDM to run a certain set of goals on a Node project versus a Java project, you could set something up like this:

```typescript
sdm.withPushRules(
    whenPushSatisfies(IsMaven).setGoals(javaGoals),
    whenPushSatisfies(IsNode).setGoals(nodeGoals)
);
```

There are a lot of push rules you can create with push tests, including scoping by branches or files. For more information, check out our section on [writing push tests](https://docs.atomist.com/developer/push-test/).

## Conclusion

We've covered just the surface of what an SDM can do. We walked through breaking up tasks, assigned them to goals, and conditionally executing those goals based on the project's primary language.

What is missing from this page? Please tell us! There's a #docs
channel in [Atomist community Slack][join], or you can create an issue
on [this repository][this-repo].

[join]: https://join.atomist.com/ "Atomist community Slack"
[this-repo]: https://github.com/atomist/docs "Atomist Docs repository"
